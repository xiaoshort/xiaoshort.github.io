<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>个人博客</subtitle>
  <link href="http://xiaoshort.github.io/xiaoshort.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaoshort.github.io/xiaoshort.github.io/"/>
  <updated>2022-10-26T09:32:29.152Z</updated>
  <id>http://xiaoshort.github.io/xiaoshort.github.io/</id>
  
  <author>
    <name>周亚</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springboot自动装配解析</title>
    <link href="http://xiaoshort.github.io/xiaoshort.github.io/2022/10/23/bean%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    <id>http://xiaoshort.github.io/xiaoshort.github.io/2022/10/23/bean%E7%9A%84%E5%8A%A0%E8%BD%BD/</id>
    <published>2022-10-23T15:57:17.176Z</published>
    <updated>2022-10-26T09:32:29.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring的bean加载"><a href="#spring的bean加载" class="headerlink" title="spring的bean加载"></a>spring的bean加载</h2><p>​我们都知道，springboot框架是在spring框架上做的升级，想要了解springboot的自动装配，就要先了解spring的bean加载。</p><h3 id="bean的加载"><a href="#bean的加载" class="headerlink" title="bean的加载"></a>bean的加载</h3><h4 id="基于xml方式加载bean"><a href="#基于xml方式加载bean" class="headerlink" title="基于xml方式加载bean"></a>基于xml方式加载bean</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--xml方式声明自定义的bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.huangzx.bean.Cat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  <span class="comment">&lt;!--命名id--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.huangzx.bean.Dog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  <span class="comment">&lt;!--未命名id--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.huangzx.bean.Dog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.huangzx.bean.Dog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="基于xml方式加载第三方bean"><a href="#基于xml方式加载第三方bean" class="headerlink" title="基于xml方式加载第三方bean"></a>基于xml方式加载第三方bean</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 首先在pom.xml中导入第三方bean坐标</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在配置文件中  xml方式声明第三方bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="基于xml-注解的方式加载bean"><a href="#基于xml-注解的方式加载bean" class="headerlink" title="基于xml+注解的方式加载bean"></a>基于xml+注解的方式加载bean</h4><p>首先要准备context的命名空间，然后通过context中的component-scan在指定要扫描的包，加载所有包下有使用@Component及其衍生注解@Controller 、@Service、@Repository，@Configuration定义bean的对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--xml方式声明自己开发的bean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定加载bean的位置，component--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.huangzx.bean,com.huangzx.config&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="基于注解的方式加载bean"><a href="#基于注解的方式加载bean" class="headerlink" title="基于注解的方式加载bean"></a>基于注解的方式加载bean</h4><p>编写一个配置类，这个类可以代替xml文件的配置，并使用@ComponentScan注解完成包的扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qing.config;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.qing.bean&quot;,&quot;com.qing.config&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig3</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qing.app;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.qing.bean.Cat;</span><br><span class="line"><span class="keyword">import</span> com.qing.config.SpringConfig3;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig3.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">jerry</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;jerry&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cat</span> <span class="operator">=</span> ctx.getBean(Cat.class);</span><br><span class="line">        String[] names = ctx.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name: names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 用这个<strong>new AnnotationConfigApplicationContext()</strong> 读取配置类   </p><h4 id="基于注解的方式加载第三方bean"><a href="#基于注解的方式加载第三方bean" class="headerlink" title="基于注解的方式加载第三方bean"></a>基于注解的方式加载第三方bean</h4><p>在扫描包的配置类中添加@Bean注解，返回第三方的对象来加载bean，此方法也适用于加载自定义的bean，只不过较为繁琐，无特殊要求，使用第一种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qing.config;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.qing.bean&quot;,&quot;com.qing.config&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig3</span> &#123;</span><br><span class="line"><span class="meta">@Bean(id=&quot;ds&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DruidDataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line"><span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-import注解加载bean"><a href="#使用-import注解加载bean" class="headerlink" title="使用@import注解加载bean"></a>使用@import注解加载bean</h4><p>在配置类上直接加上@import注解。传入对象的class反射对象即可注入bean对象</p><blockquote><p>这种技术可以减少源代码与spring技术的耦合度，在spring技术底层及诸多框架的整合中大量使用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(User.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Beanconfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用上下文对象（AnnotationConfigApplicationContext）在容器初始化完毕后加载bean"><a href="#使用上下文对象（AnnotationConfigApplicationContext）在容器初始化完毕后加载bean" class="headerlink" title="使用上下文对象（AnnotationConfigApplicationContext）在容器初始化完毕后加载bean"></a>使用上下文对象（AnnotationConfigApplicationContext）在容器初始化完毕后加载bean</h4><blockquote><p>这是一种手动导入bean的方式，在应用上下文创建成功后使用其中的</p></blockquote><img src="/2022/10/23/bean%E7%9A%84%E5%8A%A0%E8%BD%BD/image-20221024191348557.png" class="" title="image-20221024191348557"><p>注：当创建多个bean时，按照创建顺序，后面的bean会覆盖前面的bean对象</p><h4 id="Import导入ImportSelector接口加载bean"><a href="#Import导入ImportSelector接口加载bean" class="headerlink" title="@Import导入ImportSelector接口加载bean"></a>@Import导入ImportSelector接口加载bean</h4><ol><li>创建一个类作为ImportSelect类，继承ImportSelector接口，实现接口中的selectImports()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportSelector;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelect</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;desktopshop.Entity.User&quot;</span>,<span class="string">&quot;desktopshop.Entity.Address&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在一个类上使用@import注解来引入我们刚刚创建的ImpotSelect类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;User.class,MyImportSelect.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Beanconfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>方法中需要返回一个字符串，在字符串中添加对象的全路径名，之后就可以将添加到字符串集合的对象加载成bean</li><li>selectImport方法中的参数AnnotationMetadata（元数据）中提供了众多的方法，可以对添加@Import注解的那个类进行检查属性，根据属性的不同，动态的加载bean</li></ol><img src="/2022/10/23/bean%E7%9A%84%E5%8A%A0%E8%BD%BD/image-20221024191921407.png" class="" title="image-20221024191921407"><img src="/2022/10/23/bean%E7%9A%84%E5%8A%A0%E8%BD%BD/image-20221024193409030.png" class="" title="image-20221024193409030"><h4 id="Import导入ImportBeanDefinitionRegistrar接口加载bean"><a href="#Import导入ImportBeanDefinitionRegistrar接口加载bean" class="headerlink" title="@Import导入ImportBeanDefinitionRegistrar接口加载bean"></a>@Import导入ImportBeanDefinitionRegistrar接口加载bean</h4><ol><li><p>创建一个类作为ImportSelect类，继承ImportBeanDefinitionRegistrar接口，实现接口中的registerBeanDefinitions()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelect</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过BeanDefinition的注册器注册实名bean，<strong>实现对容器中bean的裁定，例如对现有bean的覆盖，进而达成不修改源代码的情况下更换实现的效果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelect</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//metatada......</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition1</span> <span class="operator">=</span> BeanDefinitionBuilder.rootBeanDefinition(User.class).getBeanDefinition();</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition2</span> <span class="operator">=</span> BeanDefinitionBuilder.rootBeanDefinition(Address.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;User&quot;</span>,beanDefinition1);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;Address&quot;</span>,beanDefinition2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们依然可以通过参数列表中的AnnotationMetadata来进行注解的属性检查动态注册bean，是ImportSelect接口的进阶版</p></li></ol><h4 id="Import导入BeanDefinitionRegistryPostProcessor接口加载bean"><a href="#Import导入BeanDefinitionRegistryPostProcessor接口加载bean" class="headerlink" title="@Import导入BeanDefinitionRegistryPostProcessor接口加载bean"></a>@Import导入BeanDefinitionRegistryPostProcessor接口加载bean</h4><blockquote><p>实现方式跟上面两种类似</p><p>实现这个接口的Importselect比实现ImportBeanDefinitionRegistrar接口的优先级更高，当同时存在且存在同名bean时，会覆盖所有其他接口注册过的bean</p><p>注：多个ImportBeanDefinitionRegistrar接口之间的执行顺序按照@import注解的填入顺序，靠左的顺序靠前，靠后的会覆盖前面的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.huangzx.service.impl.BookServiceImpl4;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;bookService&quot;</span>,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="几种bean加载的优先级"><a href="#几种bean加载的优先级" class="headerlink" title="几种bean加载的优先级"></a>几种bean加载的优先级</h4><blockquote><p>annotationApplicationcontext &gt; BeanDefinitionRegistryPostProcessor &gt; ImportBeanDefinitionRegistrar &gt; ImportSelector</p></blockquote><h3 id="bean的加载控制"><a href="#bean的加载控制" class="headerlink" title="bean的加载控制"></a>bean的加载控制</h3><h4 id="编程式控制"><a href="#编程式控制" class="headerlink" title="编程式控制"></a>编程式控制</h4><p><code>annotationApplicationcontext</code>、<code>BeanDefinitionRegistryPostProcessor</code>、<code>ImportBeanDefinitionRegistrar</code> 、<code>ImportSelector</code>四种方式都可以实现控制<code>bean</code>的加载，拿<code>ImportSelector</code>举例:</p><p>​先去判断是否具有class对象从而判断是否注入了Mouse的bean，从而控制Cat的bean的加载</p><img src="/2022/10/23/bean%E7%9A%84%E5%8A%A0%E8%BD%BD/image-20221025155637708.png" class="" title="image-20221025155637708"><h4 id="注解式控制"><a href="#注解式控制" class="headerlink" title="注解式控制"></a>注解式控制</h4><p>spring框架提供有@ComditionalOnXXXX 类型的注解，放在加载的bean上可以控制该bean是否被加载</p><p>常见的注解有：</p><blockquote><ul><li><p><strong>@ConditionalOnBean</strong> </p><p>当指定的bean存在时，则实例化当前的bean</p></li><li><p><strong>@ConditionalOnMissingBean</strong> </p><p>当给定的在bean不存在时,则实例化当前Bean</p></li><li><p><strong>@ConditionalOnClass</strong> </p><p>当前classpath下存在指定类，则实例化当前Bean</p></li><li><p><strong>@ConditionalOnMissingClass</strong></p><p> 当前classpath下不存在指定类，则实例化当前Bean</p></li><li><p><strong>@ConditionalOnProperty</strong></p><p>控制配置类是否生效,可以将配置与代码进行分离,实现了更好的控制配置<br>如：<code>@ConditionalOnProperty(prefix = &quot;filter&quot;, name = &quot;loginFilter&quot;, havingValue = &quot;true&quot;)</code>，配置文件代码为：<code>filter.loginFilter=true</code></p></li><li><p><strong>@ConditionalOnWebApplication</strong> </p><p>当Spring为web服务时，才使注解的类生效；通常是配置类;</p></li><li><p><strong>@ConditionalOnNotWebApplication</strong></p><p> 当Spring不是web服务时，才使注解的类生效；通常是配置类</p></li></ul></blockquote><img src="/2022/10/23/bean%E7%9A%84%E5%8A%A0%E8%BD%BD/image-20221025165128003.png" class="" title="image-20221025165128003"><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote><p>首先需要了解一下什么是工厂模式</p><p><a href="https://blog.csdn.net/a745233700/article/details/120253639?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166652795216782388091298%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166652795216782388091298&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120253639-null-null.142%5Ev59%5Epc_search_tree,201%5Ev3%5Econtrol_1&utm_term=%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187">设计模式：工厂模式</a></p></blockquote><p>实现如下：</p><ol><li><p>创建XXXFactoryBean的工厂类，并实现FactoryBean&lt; XXX &gt;接口</p></li><li><p>实现接口中的 <code>getObject()</code>、<code>getObjectType()</code>、<code>isSIngleton()</code>三个方法</p></li><li><p>方法中对应返回XXX对象和XXX的class对象即可，另外方法中还可以做其他准备工作，如数据校验、属性加载、算法优化，将其操作与bean的创建一同打包，这就是工厂模式的精髓之处</p></li><li><p>在扫描包的配置类中加载（添加<code>@Bean</code>注解），返回值类型为XXXFactoryBean</p></li></ol><blockquote><p>​注：一般情况来说，加载的<code>bean</code>对象就是方法中返回的对象类型，但是工厂模式比较特殊，它加载的<code>bean</code>是对应方法实现的Factory&lt; XXX &gt;的范型的类型</p></blockquote><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> desktopshop.Entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;User&gt; &#123;</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         <span class="comment">//默认用户名（用户未起名的话）</span></span><br><span class="line">        user.setUsername(UUID.randomUUID().toString());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FactoryBean.<span class="built_in">super</span>.isSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserFactoryBean <span class="title function_">createUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserFactoryBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解方式混合xml文件配置"><a href="#注解方式混合xml文件配置" class="headerlink" title="注解方式混合xml文件配置"></a>注解方式混合xml文件配置</h3><blockquote><p>在进行二次开发时，可能会碰到原来开发的代码是基于xml文件编写的，而二次开发需要使用注解</p></blockquote><p>在bean配置类上添加<code>@ImportResource（“xml文件名称”）</code>的注解，即可导入xml中的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;XXXXXXX&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserFactoryBean <span class="title function_">createUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserFactoryBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于proxyBeanMethods属性"><a href="#关于proxyBeanMethods属性" class="headerlink" title="关于proxyBeanMethods属性"></a>关于proxyBeanMethods属性</h4><p>​<code>@Configuration</code>注解作为<code>@Conponent</code>的衍生类，和<code>@Conponent</code>的作用都是加载<code>Bean</code>，但是也稍有不同</p><p>​<code>@Configuration</code>注解中含有<code>proxyBeanMethods</code>这一属性，选择<code>true</code>或<code>flase</code>来控制调用此方法得到的对象是从容器中获取的还是重新创建的 </p><p>​<code>true</code>表示开启代理对象模式，从容器中获取对象，<code>false</code>表示非代理对象，从容器中获取对象</p><img src="/2022/10/23/bean%E7%9A%84%E5%8A%A0%E8%BD%BD/image-20221023235719672.png" class="" title="image-20221023235719672"><h3 id="bean的依赖属性控制"><a href="#bean的依赖属性控制" class="headerlink" title="bean的依赖属性控制"></a>bean的依赖属性控制</h3><p>​在SpringBoot中注解<code>@ConfigurationProperties</code>有三种使用场景，而通常情况下我们使用的最多的只是其中的一种场景。本篇文章带大家了解一下三种场景的使用情况</p><h4 id="ConfigurationProperties-Component"><a href="#ConfigurationProperties-Component" class="headerlink" title="@ConfigurationProperties+@Component"></a>@ConfigurationProperties+@Component</h4><p>​使用<code>@ConfigurationProperties</code>和<code>@Component</code>注解到<code>bean</code>定义类上，这里<code>@Component</code>代指同一类实例化<code>Bean</code>的注解</p><p>​在此种场景下，当<code>Bean</code>被实例化时，<code>@ConfigurationProperties</code>会将对应前缀的后面的属性与<code>Bean</code>对象的属性匹配。符合条件则进行赋值</p><p>基本使用实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将类定义为一个bean的注解，比如 @Component,@Service,@Controller,@Repository</span></span><br><span class="line"><span class="comment">// 或者 @Configuration</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 表示使用配置文件中前缀为user1的属性的值初始化该bean定义产生的的bean实例的同名属性</span></span><br><span class="line"><span class="comment">// 在使用时这个定义产生的bean时，其属性name会是Tom</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;user1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">// 省略getter/setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应<code>application.properties</code>配置文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user1.name=Tom</span><br></pre></td></tr></table></figure><h4 id="ConfigurationProperties-Bean"><a href="#ConfigurationProperties-Bean" class="headerlink" title="@ConfigurationProperties+@Bean"></a>@ConfigurationProperties+@Bean</h4><p>​使用<code>@ConfigurationProperties</code>和<code>@Bean</code>注解在配置类的<code>Bean</code>定义方法上。以数据源配置为例,将前缀为<code>“spring.datasource.primary”</code>的属性，赋值给<code>DataSource</code>对应的属性值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Bean(name = &quot;primaryDataSource&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;spring.datasource.primary&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">primaryDataSource</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConfigarationProperties-EnableConfigurationProperties"><a href="#ConfigarationProperties-EnableConfigurationProperties" class="headerlink" title="@ConfigarationProperties+@EnableConfigurationProperties"></a>@ConfigarationProperties+@EnableConfigurationProperties</h4><p>使用<code>@ConfigurationProperties</code>注解到普通类，然后再通过<code>@EnableConfigurationProperties</code>定义为<code>Bean</code>，这里<code>@EnableConfigurationProperties</code>可以直接将传进来的对象加载成<code>bean</code>，也算一种特殊的<code>bean</code>加载的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;user1&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>User</code>对象并没有使用<code>@Component</code>相关注解</p><p>而该<code>User</code>类对应的使用形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;User.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="springboot的自动装配"><a href="#springboot的自动装配" class="headerlink" title="springboot的自动装配"></a>springboot的自动装配</h2><h3 id="解析-springBootApplication源码"><a href="#解析-springBootApplication源码" class="headerlink" title="解析@springBootApplication源码"></a>解析@springBootApplication源码</h3><blockquote><p><strong><code>SpringBootApplication</code></strong></p><ul><li><code>@SpringBootConfiguration</code><ul><li><code>@Configuration</code></li><li><code>@Indexed</code> (加速启动spring boot)</li></ul></li><li><code>@EnableAutoConfiguration</code><ul><li><code>@AutoConfigurationPackage</code><ul><li><code>@Import(AutoConfigurationPakages.Register.class)</code></li></ul></li><li><code>@Import(AutoConfigurationImportSelector.class)</code></li></ul></li><li><code>@ComponentScan(excludeFilters)</code></li></ul></blockquote><h3 id="bean加载的实现"><a href="#bean加载的实现" class="headerlink" title="bean加载的实现"></a>bean加载的实现</h3><p>​<code>AutoConfigurationPakages.Register</code>实现了<code>ImportBeanDefinitionRegister</code>接口，作为<code>bean</code>的注册器，其作用是结合<code>AutoConfigurationPakages</code>设置当前所在的包作为扫描包，后续要针对当前的包进行扫描，并注册自定义的<code>bean</code></p><p>​<code>AutoConfigurationImportSelector</code>实现了<code>DeferredImportSelector</code>，而<code>DeferredImportSelector</code>是<code>ImportSelector</code>的扩展（扩展了在接口继承实现中推迟加载的设定），因此<code>AutoConfigurationImportSelector</code>负责调用<code>SpringFactoriesLoader</code>(另一个类)来加载预先准备好的技术集（各种技术的<code>configuration</code>），从而加载<code>bean</code></p><h3 id="第三方bean的属性加载的实现"><a href="#第三方bean的属性加载的实现" class="headerlink" title="第三方bean的属性加载的实现"></a>第三方bean的属性加载的实现</h3><p>拿<code>RedisConfiguration</code>配置类举例：</p><img src="/2022/10/23/bean%E7%9A%84%E5%8A%A0%E8%BD%BD/image-20221025214826525.png" class="" title="image-20221025214826525"><ul><li><p>@Configuration                        作为配置类</p></li><li><p>@ConditionalOnclass                              当有Redis的jar包才加载此类，实现动态加载</p></li><li><p>@EnableConfigurationProperties          加载bean的属性，其中RedisProperties中有许多默认属性，并实现      </p><p>​                                                                     了@ConfigurationProperties</p></li><li><p>@Import                                                     RedisProperties中有两个客户端对象，jedis和letten，需要单独把它   </p><p>​                                                                     们加载bean</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;spring的bean加载&quot;&gt;&lt;a href=&quot;#spring的bean加载&quot; class=&quot;headerlink&quot; title=&quot;spring的bean加载&quot;&gt;&lt;/a&gt;spring的bean加载&lt;/h2&gt;&lt;p&gt;​		我们都知道，springboot框架是在spr</summary>
      
    
    
    
    <category term="springboot原理" scheme="http://xiaoshort.github.io/xiaoshort.github.io/categories/springboot%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>initializingBean组件</title>
    <link href="http://xiaoshort.github.io/xiaoshort.github.io/2022/10/18/initializingBean%E7%BB%84%E4%BB%B6/"/>
    <id>http://xiaoshort.github.io/xiaoshort.github.io/2022/10/18/initializingBean%E7%BB%84%E4%BB%B6/</id>
    <published>2022-10-18T12:13:53.230Z</published>
    <updated>2022-10-23T16:29:32.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="initializingBean的使用"><a href="#initializingBean的使用" class="headerlink" title="initializingBean的使用"></a>initializingBean的使用</h2><h3 id="什么是initializingBean"><a href="#什么是initializingBean" class="headerlink" title="什么是initializingBean"></a>什么是initializingBean</h3><blockquote><p>intializingBean是一个可以在初始化Bean之前提供方法的接口对象</p></blockquote><h3 id="如何使用initializingBean"><a href="#如何使用initializingBean" class="headerlink" title="如何使用initializingBean"></a>如何使用initializingBean</h3><ul><li>在你需要操作的类上实现initializingBean接口</li><li>重写接口中的唯一对象afterPropertiesSet方法</li><li>该方法会在Bean被初始化之前就加载</li></ul><h3 id="如何运用initializingBean"><a href="#如何运用initializingBean" class="headerlink" title="如何运用initializingBean"></a>如何运用initializingBean</h3><p>运用1：刷新变量环境，避免干扰业务的执行</p><p>运用2：静态加载资源，如：将MySQL数据库的数据加载到redis中</p><h2 id="初始化加载顺序"><a href="#初始化加载顺序" class="headerlink" title="* 初始化加载顺序"></a>* 初始化加载顺序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInitializingBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInitializingBean</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是MyInitializingBean构造方法执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是afterPropertiesSet方法执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postConstruct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是postConstruct方法执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是init方法执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> MyInitializingBean <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyInitializingBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><img src="/2022/10/18/initializingBean%E7%BB%84%E4%BB%B6/image-20221018201357463.png" class="" title="image-20221018201357463"><blockquote><p>通过启动日志我们可以看出执行顺序优先级：构造方法 &gt; postConstruct &gt;afterPropertiesSet &gt; init方法。<br>在Spring初始化bean的时候，如果该bean实现了InitializingBean接口，并且同时在配置了init-method，系统则是先调用afterPropertieSet()方法，然后再调用init-method中指定的方法。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;initializingBean的使用&quot;&gt;&lt;a href=&quot;#initializingBean的使用&quot; class=&quot;headerlink&quot; title=&quot;initializingBean的使用&quot;&gt;&lt;/a&gt;initializingBean的使用&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    <category term="springboot组件" scheme="http://xiaoshort.github.io/xiaoshort.github.io/categories/springboot%E7%BB%84%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ快速入门</title>
    <link href="http://xiaoshort.github.io/xiaoshort.github.io/2022/10/17/rabbitmq%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://xiaoshort.github.io/xiaoshort.github.io/2022/10/17/rabbitmq%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2022-10-17T12:49:31.814Z</published>
    <updated>2022-10-23T16:26:08.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Work-Direct消息队列模型的搭建"><a href="#Work-Direct消息队列模型的搭建" class="headerlink" title="Work-Direct消息队列模型的搭建"></a>Work-Direct消息队列模型的搭建</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><blockquote><p>Rabbitmq使用的amqp协议，amqp协议也默认支持rabbitmq，所以我们只要导入amqp的依赖即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="在spring-boot中配置rabbitmq"><a href="#在spring-boot中配置rabbitmq" class="headerlink" title="在spring boot中配置rabbitmq"></a>在spring boot中配置rabbitmq</h2><blockquote><p>配置的属性比较多，这里只做入门，不详细介绍</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br></pre></td></tr></table></figure><h2 id="搭建direct队列模型"><a href="#搭建direct队列模型" class="headerlink" title="搭建direct队列模型"></a>搭建direct队列模型</h2><h3 id="了解队列模型的概念"><a href="#了解队列模型的概念" class="headerlink" title="了解队列模型的概念"></a>了解队列模型的概念</h3><blockquote><p>先可以了解一些理论知识：<a href="https://blog.csdn.net/upstream480/article/details/119149633?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166600938316782390594965%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166600938316782390594965&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-119149633-null-null.142%5Ev58%5Epc_search_tree,201%5Ev3%5Econtrol_1&utm_term=rabbitmq%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B&spm=1018.2226.3001.4187">RabbitMQ队列模型</a></p></blockquote><h3 id="初始化队列模型"><a href="#初始化队列模型" class="headerlink" title="初始化队列模型"></a>初始化队列模型</h3><ul><li>创建一个关于rabbitmq的配置类</li><li>配置中需要初始化三样东西：队列（不要导错包、可以存在多条）、交换机（这里根据路由方式选择DirectExchange）、关系（将队列与交换机进行绑定）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfigDirect</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct_queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct_queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;directExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDirect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue()).to(directExchange()).with(<span class="string">&quot;direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDirect2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2()).to(directExchange()).with(<span class="string">&quot;direct2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用AmqpTemplate操作RabbitMQ"><a href="#使用AmqpTemplate操作RabbitMQ" class="headerlink" title="使用AmqpTemplate操作RabbitMQ"></a>使用AmqpTemplate操作RabbitMQ</h3><h4 id="send方法的编写"><a href="#send方法的编写" class="headerlink" title="send方法的编写"></a>send方法的编写</h4><ul><li>借助amqp中的converAndSend方法，传入交换机和关系的名称，以及放入队列的对象，三个参数完成入队操作</li><li>注意添加@Service注解进行注入bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span>(Object o) &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendToQueue</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">&quot;directExchange&quot;</span>,<span class="string">&quot;direct&quot;</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="listener方法的编写"><a href="#listener方法的编写" class="headerlink" title="listener方法的编写"></a>listener方法的编写</h4><ul><li>借助@RabbitListeber注解，传入监听队列的名称，实现监听</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;direct_queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">receive</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者成功拿到数据!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="fanout交换机实现发布-订阅队列"><a href="#fanout交换机实现发布-订阅队列" class="headerlink" title="fanout交换机实现发布\订阅队列"></a>fanout交换机实现发布\订阅队列</h1><ul><li><p>fanout交换机的路由方式和direct交换机不同，fanout交换机不会处理路由键，所以速度更快，而direct交换机会根据路由键来指定一个消费者队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span>(Object o) &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendToQueue</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">&quot;fanoutExchange&quot;</span>,<span class="string">&quot;&quot;</span>,id);<span class="comment">//路由键不填，则表示是fanout</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>它会将消息发送给所有和它绑定的队列，就像所有人都能收到微信公众号发来的消息</p></li><li><p>用fanout交换机实现订阅队列与上述方法一致，只是交换机路由方式的不同</p></li></ul><p>注：head模式的队列用的很少，且效率较低，不做重点学习</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Work-Direct消息队列模型的搭建&quot;&gt;&lt;a href=&quot;#Work-Direct消息队列模型的搭建&quot; class=&quot;headerlink&quot; title=&quot;Work-Direct消息队列模型的搭建&quot;&gt;&lt;/a&gt;Work-Direct消息队列模型的搭建&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="rabbitmq" scheme="http://xiaoshort.github.io/xiaoshort.github.io/categories/rabbitmq/"/>
    
    
  </entry>
  
  <entry>
    <title>JeMter的安装和基本压测使用</title>
    <link href="http://xiaoshort.github.io/xiaoshort.github.io/2022/10/15/JMeter/"/>
    <id>http://xiaoshort.github.io/xiaoshort.github.io/2022/10/15/JMeter/</id>
    <published>2022-10-15T14:10:24.830Z</published>
    <updated>2022-10-18T11:51:13.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jmeter的安装"><a href="#Jmeter的安装" class="headerlink" title="Jmeter的安装"></a>Jmeter的安装</h1><ol><li><strong>jemeter的下载</strong></li></ol><p><strong>官网地址</strong>：<a href="https://jmeter.apache.org/download_jmeter.cgi">JMeter下载</a></p><p>windows选择zip包，linux选择tqz包，下载后解压缩</p><img src="/2022/10/15/JMeter/image-20221015172158106.png" class="" title="image-20221015172158106"><ol start="2"><li><p><strong>配置property</strong></p><p>打开下载好的jemeter中的bin目录下的property文件关闭 SSL，JMeter 软件打开后默认会使用 SSL，如果电脑中没有安装 SSL，则 JMeter 在第一次打开后会报错。在文件 <code>jmeter.properties</code> 中使用如下代码关闭 SSL。关闭之后，以后打开 JMeter 就不会报错了</p><p>大概在配置文件的第335行左右，修改成如下代码即可完成修改：</p><p><code>server.rmi.ssl.disable=true</code></p></li><li><p><strong>运行jemeter</strong></p><p>找到bin文件夹中的jemeter.bat即可运行jemeter，有需要的还可以为bat文件创建快捷方式，方便以后使用</p></li></ol><img src="/2022/10/15/JMeter/image-20221015205013638.png" class="" title="image-20221015205013638"><h1 id="JMeter基本使用"><a href="#JMeter基本使用" class="headerlink" title="JMeter基本使用"></a>JMeter基本使用</h1><p>介绍无参数的压测实例</p><h3 id="设置线程组"><a href="#设置线程组" class="headerlink" title="设置线程组"></a>设置线程组</h3><ol><li>按下图添加一个线程组</li></ol><img src="/2022/10/15/JMeter/image-20221015210507018.png" class="" title="image-20221015210507018"><ol start="2"><li>线程组中有下列的属性可以配置</li></ol><img src="/2022/10/15/JMeter/image-20221015210704123.png" class="" title="image-20221015210704123"><ul><li>名称：随便命名即可</li><li>线程数：也就是进行压测的线程数量，可以调整线程数进行不同程度的压测</li><li>Ramp-up时间：实行线程的时长，填0表示自动</li><li>循环次数：循环此次压测的次数，意思就是，最终的压测线程数是，线程数*循环次数</li></ul><h3 id="添加HTTP请求默认值的配置元件"><a href="#添加HTTP请求默认值的配置元件" class="headerlink" title="添加HTTP请求默认值的配置元件"></a>添加HTTP请求默认值的配置元件</h3><ol><li>按如下图为线程组添加配置元件</li></ol><img src="/2022/10/15/JMeter/image-20221015211828549.png" class="" title="image-20221015211828549"><ol start="2"><li>元件中有如下配置</li></ol><img src="/2022/10/15/JMeter/image-20221015211954462.png" class="" title="image-20221015211954462"><ul><li>名称：随便命名</li><li>web服务器：你进行压测的服务器和端口</li><li>http请求：进行压测的具体url地址</li><li>参数：携带参数进行请求</li></ul><ol start="3"><li>在web服务器中填入服务器和端口作为默认值，http请求暂时不填</li></ol><h3 id="添加HTTP请求的取样器"><a href="#添加HTTP请求的取样器" class="headerlink" title="添加HTTP请求的取样器"></a>添加HTTP请求的取样器</h3><ol><li>如下图为线程组添加取样器</li></ol><img src="/2022/10/15/JMeter/image-20221015212658453.png" class="" title="image-20221015212658453"><p>2.取样器中有如下配置</p><img src="/2022/10/15/JMeter/image-20221015212757930.png" class="" title="image-20221015212757930"><ul><li>名称：随便起</li><li>web服务器：刚才已经配置了默认值，在取样器中无需重复配置</li><li>HTTP请求：填入你压测的url地址</li></ul><p>注：由于同时进行压测的url地址可以有多个，因此取样器也可以配置多个</p><h3 id="添加监听器"><a href="#添加监听器" class="headerlink" title="添加监听器"></a>添加监听器</h3><ol><li>按如下图添加监听器</li></ol><img src="/2022/10/15/JMeter/image-20221015213502252.png" class="" title="image-20221015213502252"><ol start="2"><li>监听器是返回请求结果和测试状态的显示页面，可以根据需求选择不同的视图</li></ol><h3 id="开启测试"><a href="#开启测试" class="headerlink" title="开启测试"></a>开启测试</h3><img src="/2022/10/15/JMeter/image-20221015214055058.png" class="" title="image-20221015214055058"><p>点击绿色的开始，即可开始压测，压测之前请确保项目以及启动</p><img src="/2022/10/15/JMeter/image-20221015214156516.png" class="" title="image-20221015214156516"><p>该页面是询问知否保存此次压测的配置，根据自己需要进行选择</p><h3 id="查看并发处理能力"><a href="#查看并发处理能力" class="headerlink" title="查看并发处理能力"></a>查看并发处理能力</h3><ol><li>添加，监听器-聚合报告</li></ol><img src="/2022/10/15/JMeter/image-20221015214927691.png" class="" title="image-20221015214927691"><ol start="2"><li>压测过程中数值会动态的变化，我们可以通过吞吐量（的最大值）来判断其处理并发的能力</li></ol><p>如：<img src="/2022/10/15/JMeter/image-20221015215118656.png" class="" title="image-20221015215118656"></p><blockquote><p>吞吐量越高，处理异常的能力越强。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Jmeter的安装&quot;&gt;&lt;a href=&quot;#Jmeter的安装&quot; class=&quot;headerlink&quot; title=&quot;Jmeter的安装&quot;&gt;&lt;/a&gt;Jmeter的安装&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;jemeter的下载&lt;/strong&gt;&lt;/li&gt;
&lt;/o</summary>
      
    
    
    
    <category term="springboot测试" scheme="http://xiaoshort.github.io/xiaoshort.github.io/categories/springboot%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>windows版的Rabbitmq安装</title>
    <link href="http://xiaoshort.github.io/xiaoshort.github.io/2022/10/15/rabbitmq%E5%AE%89%E8%A3%85/"/>
    <id>http://xiaoshort.github.io/xiaoshort.github.io/2022/10/15/rabbitmq%E5%AE%89%E8%A3%85/</id>
    <published>2022-10-15T08:30:48.165Z</published>
    <updated>2022-10-18T11:51:34.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rabbitmq的安装（Windows）"><a href="#Rabbitmq的安装（Windows）" class="headerlink" title="Rabbitmq的安装（Windows）"></a>Rabbitmq的安装（Windows）</h1><blockquote><p>rabbitmq是基于erlang进行编写的，所以首先我们要下载erlang环境，erlang的版本要与rabbitmq相适配，具体见rabbitmq文档的官方说明</p></blockquote><h2 id="Erlang的下载"><a href="#Erlang的下载" class="headerlink" title="Erlang的下载"></a>Erlang的下载</h2><p>官方下载地址：<a href="https://erlang.org/download/otp_versions_tree.html">https://erlang.org/download/otp_versions_tree.html</a></p><p>根据自己的系统进行选择</p><p><img src="/imgs%5Ce8cee75dc984466a822bf879931470c0.png" alt="e8cee75dc984466a822bf879931470c0.png"></p><p>（<a href="https://blog.csdn.net/qq_50119033/article/details/126158177?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166600284916782391871827%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166600284916782391871827&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-126158177-null-null.142%5Ev58%5Epc_search_tree,201%5Ev3%5Econtrol_1&utm_term=Windows%20rabbitmq%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">图片出处</a>）</p><ol><li>以管理员身份运行exe文件，安装erlang（注意安装位置的路径不能有中文和空格！）</li><li>配置erlang的系统环境变量</li></ol><img src="/2022/10/15/rabbitmq%E5%AE%89%E8%A3%85/image-20221017184213438.png" class="" title="image-20221017184213438"><ol start="3"><li>cmd上运行erl -v 观察到版本号说明安装成功了</li></ol><img src="/2022/10/15/rabbitmq%E5%AE%89%E8%A3%85/image-20221017184403283.png" class="" title="image-20221017184403283"><h2 id="下载Rabbitmq"><a href="#下载Rabbitmq" class="headerlink" title="下载Rabbitmq"></a>下载Rabbitmq</h2><p>下载地址：<a href="https://github.com/rabbitmq/rabbitmq-server/releases">Releases · rabbitmq&#x2F;rabbitmq-server · GitHub</a> </p><img src="/2022/10/15/rabbitmq%E5%AE%89%E8%A3%85/image-20221017184604803.png" class="" title="image-20221017184604803"><ol><li><p>以管理员的身份运行exe文件，同上要注意安装的路径不能含有中文和空格</p></li><li><p>同上配置RABBITMQ_SERVER的环境变量</p></li><li><p>cmd  rabbitmqctl status  查看环境变量是否配置正确，安装成功结果如图所示</p><img src="/2022/10/15/rabbitmq%E5%AE%89%E8%A3%85/image-20221017191755061.png" class="" title="image-20221017191755061"></li><li><p>cmd  rabbitmq-plugins enable rabbitmq_management 来执行安装Rabbitmq Web的插件</p><img src="/2022/10/15/rabbitmq%E5%AE%89%E8%A3%85/image-20221017191845039.png" class="" title="image-20221017191845039"></li><li><p>打开浏览器输入：<a href="http://localhost:15672/">http://localhost:15672/</a>     默认的用户名和密码：guest</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rabbitmq的安装（Windows）&quot;&gt;&lt;a href=&quot;#Rabbitmq的安装（Windows）&quot; class=&quot;headerlink&quot; title=&quot;Rabbitmq的安装（Windows）&quot;&gt;&lt;/a&gt;Rabbitmq的安装（Windows）&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="rabbitmq" scheme="http://xiaoshort.github.io/xiaoshort.github.io/categories/rabbitmq/"/>
    
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="http://xiaoshort.github.io/xiaoshort.github.io/2020/03/10/markdown%E8%AF%AD%E6%B3%95/"/>
    <id>http://xiaoshort.github.io/xiaoshort.github.io/2020/03/10/markdown%E8%AF%AD%E6%B3%95/</id>
    <published>2020-03-10T04:30:16.000Z</published>
    <updated>2022-10-18T11:50:33.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markdown语法的使用"><a href="#markdown语法的使用" class="headerlink" title="markdown语法的使用"></a>markdown语法的使用</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><hr><h2 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure><hr><h2 id="3-下划线、删除线"><a href="#3-下划线、删除线" class="headerlink" title="3.下划线、删除线"></a>3.下划线、删除线</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~~删除线~~</span><br><span class="line"></span><br><span class="line">&lt;u&gt;下划线&lt;/u&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="3-分点条列"><a href="#3-分点条列" class="headerlink" title="3.分点条列"></a>3.分点条列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 第一行</span><br><span class="line">* 第二行</span><br><span class="line"></span><br><span class="line">- 第一行</span><br><span class="line">- 第二行</span><br><span class="line"></span><br><span class="line">+ 第一行</span><br><span class="line">+ 第二行</span><br></pre></td></tr></table></figure><hr><h2 id="4-区块"><a href="#4-区块" class="headerlink" title="4.区块"></a>4.区块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; markdown</span><br><span class="line">&gt; 基础</span><br><span class="line">&gt; 区块引用</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="5-插入代码"><a href="#5-插入代码" class="headerlink" title="5.插入代码"></a>5.插入代码</h2><ul><li><strong>插入一行代码</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`int a = 0;`//英文版的数字1左边的那个符号。。。。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><strong>插入代码块</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">​```紧跟着可以写上用的什么语言，也可以不用写。</span><br><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line">​```结尾与开头一样</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-插入链接"><a href="#6-插入链接" class="headerlink" title="6.插入链接"></a>6.插入链接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line">或者</span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="7-插入图片"><a href="#7-插入图片" class="headerlink" title="7.插入图片"></a>7.插入图片</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片描述，可写可不写，但是中括号要有](图片地址，本地链接或者URL地址。)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="8-插入表格"><a href="#8-插入表格" class="headerlink" title="8.插入表格"></a>8.插入表格</h2><ul><li><strong>每排单元格要用 | 分开 表头与内容用 - 分开</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|  表头   | 表头  | 表头 | 表头 |</span><br><span class="line">| :---  | ---:  | :--: | ---- |</span><br><span class="line">| 单元格  | 单元格 |单元格|单元格|</span><br><span class="line">| 单元格  | 单元格 |单元格|单元格|</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">markdown语法的全部使用</summary>
    
    
    
    <category term="其他" scheme="http://xiaoshort.github.io/xiaoshort.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>HandlerInterceptor实现拦截器</title>
    <link href="http://xiaoshort.github.io/xiaoshort.github.io/2020/03/10/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://xiaoshort.github.io/xiaoshort.github.io/2020/03/10/%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2020-03-10T04:30:16.000Z</published>
    <updated>2022-10-12T07:11:41.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVC拦截器快速开发"><a href="#MVC拦截器快速开发" class="headerlink" title="MVC拦截器快速开发"></a>MVC拦截器快速开发</h1><h2 id="拦截器简单介绍"><a href="#拦截器简单介绍" class="headerlink" title="拦截器简单介绍"></a>拦截器简单介绍</h2><ul><li>拦截器的功能与filter过滤器类似，但其实现方式不相同</li><li>拦截器的作用是拦截客户端传来的请求，再根据规定的条件进行请求放行</li></ul><h2 id="spring-boot配置拦截器"><a href="#spring-boot配置拦截器" class="headerlink" title="spring boot配置拦截器"></a>spring boot配置拦截器</h2><p>拦截器的配置分为两个部分：拦截器的定义、拦截器的注册</p><h3 id="定义拦截器"><a href="#定义拦截器" class="headerlink" title="定义拦截器"></a>定义拦截器</h3><ul><li>创建一个类作为拦截器，使这个类实现Handelerinterceptor接口</li><li>实现接口中的三个方法：prehandle（）、posthandle（）、afterhandle（）</li><li>在对应的方法中编写拦截逻辑，其中return false代表拦截，return true代表放行</li></ul><h3 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h3><ul><li>用＠Configration声明一个关于拦截器的配置类，并让这个类实现WebMvcConfigurer接口</li><li>重写借口中的addInterceptors方法（参数列表为InterceptorRegister）</li><li>预先使用new创建刚刚定义的拦截器，预先创建list集合，存放拦截白名单的地址</li><li>在方法中使用方法如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InterceptorRegister.addInterceptor(定义的拦截器).addPathPatterns(<span class="string">&quot;/**&quot;</span>).excludePathPatterns(拦截白名单);</span><br></pre></td></tr></table></figure></li></ul><h2 id="拦截器的实际应用"><a href="#拦截器的实际应用" class="headerlink" title="拦截器的实际应用"></a>拦截器的实际应用</h2><ul><li>拦截器通常用于登陆功能的验证，通过检查上下文中session里是否具有用户信息来确定是否放行请求</li><li>拦截器的白名单通常为：html、css、js等静态资源，不需要通过登录就可以访问的页面，注册请求和登录请求</li></ul>]]></content>
    
    
    <summary type="html">spring boot整合MVC拦截器</summary>
    
    
    
    <category term="spring boot组件,拦截器" scheme="http://xiaoshort.github.io/xiaoshort.github.io/categories/spring-boot%E7%BB%84%E4%BB%B6-%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
    
    <category term=" #文章标签，可空，多标签请用格式，注意冒号:后面有个空格" scheme="http://xiaoshort.github.io/xiaoshort.github.io/tags/%E6%96%87%E7%AB%A0%E6%A0%87%E7%AD%BE%EF%BC%8C%E5%8F%AF%E7%A9%BA%EF%BC%8C%E5%A4%9A%E6%A0%87%E7%AD%BE%E8%AF%B7%E7%94%A8%E6%A0%BC%E5%BC%8F%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%86%92%E5%8F%B7-%E5%90%8E%E9%9D%A2%E6%9C%89%E4%B8%AA%E7%A9%BA%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>nginx快速入门</title>
    <link href="http://xiaoshort.github.io/xiaoshort.github.io/2020/03/10/nginx/"/>
    <id>http://xiaoshort.github.io/xiaoshort.github.io/2020/03/10/nginx/</id>
    <published>2020-03-10T04:30:16.000Z</published>
    <updated>2022-10-12T10:45:29.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx的快速入门"><a href="#nginx的快速入门" class="headerlink" title="nginx的快速入门"></a>nginx的快速入门</h1><p>注：本文是基于Windows进行学习的nginx</p><h2 id="1-nginx的安装部署"><a href="#1-nginx的安装部署" class="headerlink" title="1.nginx的安装部署"></a>1.nginx的安装部署</h2><ul><li>参考CSDN的这篇文章<br><a href="https://blog.csdn.net/cjw12581/article/details/107404047?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166548690916782390595918%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166548690916782390595918&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-107404047-null-null.142^v52^control,201^v3^control_1&utm_term=nginxwindows%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&spm=1018.2226.3001.4187">nginx安装部署的博客链接</a></li></ul><h2 id="2-认识nginx-config文件"><a href="#2-认识nginx-config文件" class="headerlink" title="2.认识nginx.config文件"></a>2.认识nginx.config文件</h2><p>nginx.config文件主要分为三大板块，分别为：全局块、events块、http块，其中http块可以配置多个server块，每个server块又可以配置多个location块，是最重要的板块</p><h3 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h3><h4 id="user指令"><a href="#user指令" class="headerlink" title="user指令"></a>user指令</h4><ul><li>用于配置运行Nginx服务器的worker进程的用户和用户组</li></ul><h4 id="work-process指令"><a href="#work-process指令" class="headerlink" title="work process指令"></a>work process指令</h4><ul><li>2.1 <strong>master_process</strong><br>用来指定是否开启工作进程，默认为开启</li><li>2.2 <strong>worker_processes</strong><br>用于配置Nginx生成工作进程的数量，这个是Nginx服务器实现并发处理服务的关键所在。理论上来说workder process的值越大，可以支持的并发处理量也越多，但事实上这个值的设定是需要受到来自服务器自身的限制，建议将该值和服务器CPU的内核数保存一致，默认的进程数量为1。</li></ul><h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a><strong>其他指令</strong></h4><ul><li>3.1 <strong>daemon</strong><br>设定Nginx是否以守护进程的方式启动，默认为on</li><li>3.2 <strong>pid</strong><br>用来配置Nginx当前master进程的进程号ID存储的文件路径，默认为&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid，不做重点学习</li><li>3.3 <strong>error_log</strong><br>用来配置Nginx的错误日志存放路径，默认为logs&#x2F;error.log error</li><li>3.4 <strong>include</strong><br>引入其他配置文件，使nginx更灵活</li></ul><h3 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h3><h4 id="accept-mutex"><a href="#accept-mutex" class="headerlink" title="accept_mutex"></a>accept_mutex</h4><ul><li>用来设置Nginx网络连接序列化,默认为on<br>   这个配置主要可以用来解决常说的”惊群”问题。大致意思是在某一个时刻，客户端发来一个请求连接，Nginx后台是以多进程的工作模式，也就是说有多个worker进程会被同时唤醒，但是最终只会有一个进程可以获取到连接，如果每次唤醒的进程数目太多，就会影响Nginx的整体性能。如果将上述值设置为on(开启状态)，将会对多个Nginx进程接收连接进行序列号，一个个来唤醒接收，就防止了多个进程对连接的争抢。</li></ul><h4 id="multi-accept"><a href="#multi-accept" class="headerlink" title="multi_accept"></a>multi_accept</h4><ul><li>:用来设置是否允许同时接收多个网络连接，默认为off<br>   如果multi_accept被禁止了，nginx一个工作进程只能同时接受一个新的连接。否则，一个工作进程可以同时接受所有的新连接</li></ul><h4 id="worker-connnections"><a href="#worker-connnections" class="headerlink" title="worker_connnections"></a>worker_connnections</h4><ul><li>用来配置单个worker进程最大的连接数,默认为512个<br>   这里的连接数不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数</li></ul><h4 id="use"><a href="#use" class="headerlink" title="use"></a>use</h4><ul><li>用来设置Nginx服务器选择哪种事件驱动来处理网络消息<br>   可以优化nginx的性能，此处可以选择select&#x2F;poll&#x2F;epoll&#x2F;kqueue等方法，通常采用epoll函数来优化nginx</li></ul><h4 id="配置举例"><a href="#配置举例" class="headerlink" title="配置举例"></a>配置举例</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">events&#123;</span><br><span class="line">accept_mutex on;</span><br><span class="line">multi_accept on;</span><br><span class="line">worker_commections 1024;</span><br><span class="line">use epoll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h3><p>在http块中，有两行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include mime.types;</span><br><span class="line">default_type application/octet-stream;</span><br></pre></td></tr></table></figure><h4 id="default-type"><a href="#default-type" class="headerlink" title="default_type"></a>default_type</h4><ul><li>用于配置相应前端请求的默认MIME类型（一种网络资源的媒体类型）</li></ul><h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><ul><li>用来设置Nginx服务器是否使用sendfile()传输文件，该属性可以大大提高Nginx处理静态资源的性能,默认为off，建议开启</li></ul><h4 id="keepalive-timeout"><a href="#keepalive-timeout" class="headerlink" title="keepalive_timeout"></a>keepalive_timeout</h4><ul><li>用来设置长连接的超时时间,默认为75s</li></ul><blockquote><p>我们都知道HTTP是一种无状态协议，客户端向服务端发送一个TCP请求，服务端响应完毕后断开连接。如何客户端向服务端发送多个请求，每个请求都需要重新创建一次连接，效率相对来说比较多，使用keepalive模式，可以告诉服务器端在处理完一个请求后保持这个TCP连接的打开状态，若接收到来自这个客户端的其他请求，服务端就会利用这个未被关闭的连接，而不需要重新创建一个新连接，提升效率，但是这个连接也不能一直保持，这样的话，连接如果过多，也会是服务端的性能下降，这个时候就需要我们进行设置其的超时时间。</p></blockquote><h4 id="keepalive-requests"><a href="#keepalive-requests" class="headerlink" title="keepalive_requests"></a>keepalive_requests</h4><ul><li>用来设置一个keep-alive连接使用的次数，默认为100次</li></ul><h3 id="server块与location块"><a href="#server块与location块" class="headerlink" title="server块与location块"></a>server块与location块</h3><ul><li>一个server可以监听一个地址端口，其中server可以包含很多个location，用来设置请求的URI，下面为举例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">      #配置监听端口和主机名称</span><br><span class="line">      listen <span class="number">8081</span>;</span><br><span class="line">      server_name localhost;</span><br><span class="line">      #配置请求处理日志存放路径</span><br><span class="line">      access_log</span><br><span class="line">      /home/www/myweb/server1/logs/access.log server1;</span><br><span class="line">      #配置错误页面</span><br><span class="line">      error_page <span class="number">404</span> /<span class="number">404.</span>html;</span><br><span class="line">      #配置处理/server1/location1请求的location</span><br><span class="line">      location /server1/location1&#123;</span><br><span class="line">         # 路径</span><br><span class="line">         root /home/www/myweb;</span><br><span class="line">         # 目标文件</span><br><span class="line">         index index_sr1_location1.html;</span><br><span class="line">      &#125;</span><br><span class="line">      #配置处理/server1/location2请求的location</span><br><span class="line">      location /server1/location2&#123;</span><br><span class="line">         root /home/www/myweb;</span><br><span class="line">         index index_sr1_location2.html;</span><br><span class="line">      &#125;</span><br><span class="line">      #配置错误页面转向</span><br><span class="line">      location = /<span class="number">404.</span>html &#123;</span><br><span class="line">         root /home/www/myweb;</span><br><span class="line">         index <span class="number">404.</span>html;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="将nginx配置到系统环境中"><a href="#将nginx配置到系统环境中" class="headerlink" title="将nginx配置到系统环境中"></a>将nginx配置到系统环境中</h2><p>想要启动、关闭或重新加载nginx配置文件，都需要先进入到nginx的安装目录的sbin目录，然后使用nginx的二级制可执行文件来操作，相对来说操作比较繁琐。现在进行把Nginx设置成随着服务器启动就自动完成启动操作的实现。<br>参考这篇博客进行Windows版本的实现，linux版本的请自行百度<br><a href="https://blog.csdn.net/yan_fang/article/details/52584359">点击进入博客</a></p><h2 id="静态资源部署"><a href="#静态资源部署" class="headerlink" title="静态资源部署"></a>静态资源部署</h2><p>上网去搜索访问资源对于我们来说并不陌生，通过浏览器发送一个HTTP请求实现从客户端发送请求到服务器端获取所需要内容后并把内容回显展示在页面的一个过程。这个时候，我们所请 求的内容就分为两种类型，一类是静态资源、一类是动态资源。 静态资源即指在服务器端真实存在并且能直接拿来展示的一些文件，比如常见的html页面、css文件、js文件、图 片、视频等资源； 动态资源即指在服务器端真但是要想获取需要经过一定的业务逻辑处理，根据不同的条件展示在页面不同，这一部分内容，比如说报表数据展示、根据当前登录用户展示相关具体数据等资源；</p><h3 id="nginx静态资源的配置指令"><a href="#nginx静态资源的配置指令" class="headerlink" title="nginx静态资源的配置指令"></a>nginx静态资源的配置指令</h3><h4 id="1，listen"><a href="#1，listen" class="headerlink" title="1，listen"></a>1，listen</h4><ul><li>用来配置监听端口，用法比较灵活，如：<blockquote><p>listen 127.0.0.1:8000; &#x2F;&#x2F; listen localhost:8000 监听指定的IP和端口<br>listen 127.0.0.1; 监听指定IP的所有端口<br>listen 8000; 监听指定端口上的连接<br>listen *:8000; 监听指定端口上的连接</p></blockquote></li></ul><h4 id="2-default-server"><a href="#2-default-server" class="headerlink" title="2. default_server"></a>2. default_server</h4><ul><li>用来将此虚拟主机设置成默认主机。所谓的默认主机指的是如果没有匹配到对应的address:port，则会默认执行的。如果不指定默认使用的是第一个server</li></ul><h4 id="3-server-name"><a href="#3-server-name" class="headerlink" title="3. server_name"></a>3. server_name</h4><ul><li>用来设置虚拟主机服务名称,如：127.0.0.1 、 localhost 、域名[<a href="http://www.baidu.com/">www.baidu.com</a> | <a href="http://www.jd.com]">www.jd.com]</a></li></ul><h4 id="4-location"><a href="#4-location" class="headerlink" title="4. location"></a>4. location</h4><ul><li>用来设置请求的URI<br>location中又包含：<blockquote><p>root：设置请求的根目录<br>index: 设置网页的默认首页<br>error_page: 设置网站的错误页面</p></blockquote></li></ul><h3 id="静态资源优化配置"><a href="#静态资源优化配置" class="headerlink" title="静态资源优化配置"></a>静态资源优化配置</h3><ul><li><p>1.在http块使用sendfile on;</p></li><li><p>2.在location中使用tcp_nopush on;<br>该指令必须在sendfile打开的状态下才会生效，主要是用来提升网络包的传输’效率’</p></li><li><p>3.在location中使用tcp_nodelay on; (默认为on)<br>该指令必须在keep-alive连接开启的情况下才生效，来提高网络包传输的’实时性’</p></li></ul>]]></content>
    
    
    <summary type="html">windows版的nginx的使用和详解</summary>
    
    
    
    <category term="nginx" scheme="http://xiaoshort.github.io/xiaoshort.github.io/categories/nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>springboot整合Validation组件(参数校验)</title>
    <link href="http://xiaoshort.github.io/xiaoshort.github.io/2020/03/10/validation%E7%BB%84%E4%BB%B6/"/>
    <id>http://xiaoshort.github.io/xiaoshort.github.io/2020/03/10/validation%E7%BB%84%E4%BB%B6/</id>
    <published>2020-03-10T04:30:16.000Z</published>
    <updated>2022-10-18T11:50:08.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="validation组件"><a href="#validation组件" class="headerlink" title="validation组件"></a>validation组件</h1><h2 id="1-依赖配置"><a href="#1-依赖配置" class="headerlink" title="1.依赖配置"></a>1.依赖配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--validation校验组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h2><ul><li>1.<strong>在controllor中需要进行参数验证的参数上添加@valid注解，如</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/doLogin&quot;)</span></span><br><span class="line"> <span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="keyword">public</span> ResponseBean <span class="title function_">doLogin</span><span class="params">(<span class="meta">@Valid</span> LoginVo loginVo)</span> &#123;</span><br><span class="line">     log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, loginVo);</span><br><span class="line">     <span class="keyword">return</span> userService.doLogin(loginVo);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>2.<strong>在相对应的vo对象字段上添加相应的注解进行验证，如</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginVo</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length(min = 32, max = 32)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-validation的常用校验注解"><a href="#3-validation的常用校验注解" class="headerlink" title="3.validation的常用校验注解"></a>3.validation的常用校验注解</h2><blockquote><p><strong>@AssertFalse</strong><br>被注解的元素必须为false<br><strong>@AssertTrue</strong><br>被注解的元素必须为True<br><strong>@Future</strong><br>被注解的元素必须是日期，检查给定的日期是否比现在晚<br><strong>@NotNull</strong><br>被注解的元素必须不为null<br><strong>@Null</strong><br>被注解的元素必须为null<br><strong>@Past(java.util.Date&#x2F;Calendar)</strong><br>被注解的元素必须过去的日期，检查标注对象中的值表示的日期比当前早<br><strong>@Email</strong><br>被注释的元素必须是电子邮箱地址<br><strong>@NotEmpty</strong><br>被注释的对象必须为空<br><strong>@Range(min&#x3D;, max&#x3D;)</strong><br>被注释的元素必须在合适的范围内<br><strong>@Length(min&#x3D;下限, max&#x3D;上限)</strong><br>验证注解的元素值长度在min和max区间内</p></blockquote>]]></content>
    
    
    <summary type="html">validation的使用以及注解详情</summary>
    
    
    
    <category term="springboot接口" scheme="http://xiaoshort.github.io/xiaoshort.github.io/categories/springboot%E6%8E%A5%E5%8F%A3/"/>
    
    
  </entry>
  
</feed>
